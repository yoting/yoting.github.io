---
layout: post
title: Java字符串以及字符串常量池
date: 2017-07-22
categories: Java
tags: java字符串

---
&ensp;&ensp;&ensp;&ensp;字符串在程序中是最常用的数据类型，那么字符串在JVM是如何存储的呢，接下来就简单剖析一下。

### **创建字符串的两种方式**

&ensp;&ensp;&ensp;&ensp;一般定义一个字符串有两种方式，一种是使用构造器创建，比如：String s = new String（"ab"）；另一种是直接赋值使用双引号创建，比如：String s="ab";这两种方式定义字符串有本质上的区别。

- 直接构造器创建方式:String s = new String("ab");
    - 首先在heap堆中创建该字符串对象，同时让该变量直接指向堆中的对象。
    - 再看pool字符串常量池中是否有该字符串常量，如果没有就往常量池中写入一个字符串常量，此时一共创建了两个对象（堆中的对象和常量池中的对象）。
- 直接赋值双引号方式:String s = "ab";
    - 首先看pool常量池中是否有该字符串常量，如果有就直接引用，如果没有就在常量池中创建该字符串，再返回该字符串的引用。
    - 这种方式是不会在heap堆中创建对象，也就是说最多创建一个对象（常量池中的字符串对象）或者不创建对象（原常量池中有就直接引用）。

### **String的intern()方法的含义**

&emsp;&emsp;String的intern()方法的含义是，在调用此方法时候会判断字符串常量池中是否包含该字符串（或者该字符串的引用），如果包含则从池中返回这个字符串（或者这个字符串的引用），否则常量池中加入这个字符串并返回这个字符串对象的引用。结果就是在常量池中一定会有该字符串（或者该字符串的引用），同时返回该字符串在常量池中的引用。
&emsp;&emsp;但是在JDK1.6和1.7之后，intern的实现方式有变化。在1.6版本时String pool字符串常量池直接放在永久代中，如果常量池中没有需要缓存的字符串，就将字符串直接拷贝一份放到常量池中，这样就是常量池和堆是永远隔离开来的。但是在1.7和之后，String pool字符串常量池不再放在永久代，而是放在堆中，这样就可以让常量池引用堆中的对象，他两不再被隔离。如果常量池中没有需要缓存的字符串，首先看堆中有没有该字符串，如果没有，就直接创建一个该字符串放到常量池中，如果有就直接在常量池中创建一个对堆中已有字符串的引用即可。

![stringpool][1]
相比较1.6版本，1.7版本主要修改的两点是：

- 将String常量池 从 Perm 区移动到了 Java Heap区
- String调运intern方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象

### **示例代码以及解释**

参考如下代码：

```java
public static void fun1() {
	String s1 = new String("1");
	s1.intern();
	String s2 = "1";
	System.out.println(s1 == s2);//JDK1.6:false  JDK1.7:false

	String s3 = new String("a") + new String("b");
	s3.intern();
	String s4 = "ab";
	System.out.println(s3 == s4);//JDK1.6:false  JDK1.7:true
}

public static void fun2() {
	String s1 = new String("1");
	String s2 = "1";
	s1.intern();
	System.out.println(s1 == s2);//JDK1.6:false  JDK1.7:false

	String s3 = new String("a") + new String("b");
	String s4 = "ab";
	s3.intern();
	System.out.println(s3 == s4);//JDK1.6:false  JDK1.7:false
}
```

- JDK1.6解释：

&emsp;&emsp;&ensp;&ensp;对于fun1和fun2：因为常量池中的对象是直接拷贝的堆中的对象，不管什么时候执行intern方法，s1对象都指向堆，s2对象指向常量池，他俩属于完全隔离的区域，必然不相同。s3和s4道理相同。

- JDK1.7解释：
    - fun1：
        - s1首先在堆中创建一个“1”，同时在常量池中也创建“1”这个对象，同时让s1指向堆中的对象。
        - s1执行intern方法，常量池中已经有“1”这个对象，并没有意义
        - s2直接赋值时，发现常量池中已经有“1”这个对象，就直接指向常量池
        - s1指向堆，s2指向常量池，结果是指向不同
        - s3首先在堆内存中创建“ab”对象，同时s3指向堆内存中的对象，但是常量池中并没有“ab”这个对象。
        - s3执行intern方法，发现常量池中并没有“ab”这个对象，但是堆中有这个对象，因此会在常量池中创建一个引用（不是直接创建"ab"这个对象），这个引用指向了堆中的“ab”这个对象，也就是之前s3的这个对象。
        - s4赋值时，发现常量池中有“ab”这个对象的引用，就指向这个引用，实际上是指向了s3在堆中创建的对象
        - s3和s4都指向堆中的对象，因此他们的指向是相同的
    - fun2：
        - s1首先在堆中创建一个“1”，同时在常量池中也创建“1”这个对象，同时让s1指向堆中的对象。
        - s2直接看常量池中已经有对象“1”，就让s2直接指向常量池中的对象
        - 再执行s1.intern方法其实没有什么意义，此时s1和s2指向不同
        - s3首先在堆内存中创建“ab”对象，同时s3指向堆内存中的对象，但是常量池中并没有“ab”这个对象。
        - s4赋值时，发现常量池没有“ab”这个对象，就在常量池创建“ab”这个对象，同时s4指向常量池中的对象。
        - 再执行s3.intern方法其实没有什么意义，此时s3和s4指向不同


  [1]: http://ox1nrsgam.bkt.clouddn.com/StringPool.png
